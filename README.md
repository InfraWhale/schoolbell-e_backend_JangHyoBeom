# 문제 풀이

## 1번 문제
\typescript\01.ts에 풀이가 있습니다.

우선 조합의 관점에서 보자면, 하나의 조합을 만들었을 때 높은 수 일수록 큰 자리의 수로 오게끔 한다면 최댓값을 만들 수 있습니다.

예를 들어 9, 3, 1을 뽑았을 때 만들 수 있는 최댓값은 931이므로, 주어진 수 1, 3, 5, 7, 9를 내림차순으로 정렬한 뒤 1/4개로 나누는 경우, 2/3개로 나누는 경우를 구하면 됩니다.

3/2 혹은 4/1로 나누는 경우는 앞의 두 개의 경우와 사실상 같으므로 생각하지 않습니다.

selectNumber()를 호출하여 goal의 갯수 만큼 조합을 만듭니다. 예를 들어 goal이 2인 경우 5C2인 모든 경우를 selected 배열에 기록합니다.

이후 calculateAnswer()를 호출하여 selected 배열에 따라 2개의 수를 만듭니다. 예를 들어 [1, 1, 1, 0, 0]인 경우 975와 31이 만들어지고, 이를 곱해서 여태까지 나온 최댓값인 maxValue 보다 큰지 비교합니다.

만약 크다면 해당 두 수가 maxFirst와 maxSecond에 저장됩니다.

모든 조합을 다 탐색하고 maxFirst, maxSecond에 있는 값을 출력합니다.

## 2번 문제
\typescript\02.ts에 풀이가 있습니다.

주어진 지도에 따라 land를 1, sea를 0으로 변환하여 2차원 배열 arr에 넣습니다. 동시에 만들어진 배열과 같은 크기인 visited 배열을 만들어 해당 칸 방문 여부를 확인합니다.

반복문으로 arr의 모든 칸을 확인합니다. 문제에서 찾고자 하는 것은 연결된 land집합의 갯수이므로, 이미 방문하였거나 sea인 경우 다음 반복으로 넘어갑니다.

넘어가지 않았다면 깊이 우선 탐색으로 모든 연결된 땅을 찾아 방문처리 합니다. 전부 찾았다면 결과 result의 갯수를 하나 늘리고 이를 반복합니다.

모든 arr의 요소를 다 탐색하고 result에 있는 값을 출력합니다.

## 3번 문제
\03.sql에 풀이가 있습니다.

![image](https://github.com/user-attachments/assets/a6095b2f-df46-48a3-8df1-f000f4b639c7)

위와 같이 ERD를 구성하였습니다.

approval 테이블의 경우 제출자가 제출한 결재를 나타냅니다. 

해당 결재는 여러 단계로 검토될 수 있으므로 이를 approval_review에 별도 테이블로 분리하여 관리합니다.

또한 결재검토는 여러개의 상태를 가질 수 있습니다. 이를 review_status 테이블로 분리하고 아래와 같은 값을 저장하여 사용합니다.
- 1 : '검토 전'
- 2 : '검토 중'
- 3 : '승인'
- 4 : '반려'

사용자의 데이터도 저장해야 하므로 이를 users 테이블로 관리합니다.

이후 예제 데이터를 입력한 후, 특정 사용자가 처리해야 할 결재 건을 나열하는 쿼리는 approval 과 approval_review 테이블을 left outer join하여 가져옵니다. 

또한 fk로 묶인 값들 또한 left outer join을 사용하여 가져옵니다.

마지막으로 where 절에서 특정 사용자의 id값으로 조건을 주어 select문을 완성합니다.
